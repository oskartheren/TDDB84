\documentclass[conference, a4paper]{IEEEtran}
\usepackage{blindtext, graphicx, url}
\hyphenation{}


 %%% JS %%%
%Define the listing package
\usepackage{listings} %code highlighter
\usepackage{color} %use color
\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}

%Customize a bit the look
\lstset{ %
backgroundcolor=\color{white}, % choose the background color; you must add \usepackage{color} or \usepackage{xcolor}
basicstyle=\footnotesize, % the size of the fonts that are used for the code
breakatwhitespace=false, % sets if automatic breaks should only happen at whitespace
breaklines=true, % sets automatic line breaking
captionpos=b, % sets the caption-position to bottom
commentstyle=\color{mygreen}, % comment style
deletekeywords={...}, % if you want to delete keywords from the given language
escapeinside={\%*}{*)}, % if you want to add LaTeX within your code
extendedchars=true, % lets you use non-ASCII characters; for 8-bits encodings only, does not work with UTF-8
frame=single, % adds a frame around the code
keepspaces=true, % keeps spaces in text, useful for keeping indentation of code (possibly needs columns=flexible)
keywordstyle=\color{blue}, % keyword style
% language=Octave, % the language of the code
morekeywords={*,...}, % if you want to add more keywords to the set
rulecolor=\color{black}, % if not set, the frame-color may be changed on line-breaks within not-black text (e.g. comments (green here))
showspaces=false, % show spaces everywhere adding particular underscores; it overrides 'showstringspaces'
showstringspaces=false, % underline spaces within strings only
showtabs=false, % show tabs within strings adding particular underscores
% stepnumber=1, % the step between two line-numbers. If it's 1, each line will be numbered
stringstyle=\color{mymauve}, % string literal style
tabsize=2, % sets default tabsize to 2 spaces
title=\lstname % show the filename of files included with \lstinputlisting; also try caption instead of title
}
%END of listing package%

\definecolor{darkgray}{rgb}{.4,.4,.4}
\definecolor{purple}{rgb}{0.65, 0.12, 0.82}

%define Javascript language
\lstdefinelanguage{JavaScript}{
keywords={typeof, new, catch, function, return, null, catch, switch, var, if, in, while, do, else, case, break, for},
keywordstyle=\color{blue}\bfseries,
ndkeywords={class, export, boolean, throw, implements, import, this, true, false, Math},
ndkeywordstyle=\color{darkgray}\bfseries,
identifierstyle=\color{black},
sensitive=false,
comment=[l]{//},
morecomment=[s]{/*}{*/},
commentstyle=\color{purple}\ttfamily,
stringstyle=\color{red}\ttfamily,
morestring=[b]',
morestring=[b]"
}

\lstset{
language=JavaScript,
extendedchars=true,
basicstyle=\ttfamily,
showstringspaces=false,
showspaces=false,
tabsize=2,
breaklines=true,
showtabs=false,
captionpos=b
}

 %%% END JS %%%


\begin{document}
\title{How does the implementation of\\
Strategy design pattern in JavaScript\\
affect Maintainability as measured by Cyclomatic complexity and Lines of code}
\author{\IEEEauthorblockN{Oskar Ther\'{e}n}
\IEEEauthorblockA{Computer Engineering\\
The Institute of Technology at Link\"{o}ping University\\
Email: oskth878@student.liu.se}}

\maketitle

\begin{abstract}
	 In this report an implementation of the Prototype design pattern, as described by the GoF, is presented in the high-level and untyped programming language JavaScript. It is implemented into the context of an existing game, where it replaces a switch case to remove cyclomatic complexity. The cyclomatic complexity difference is compared to the difference in lines of code to evaluate how maintainability is affected.
\end{abstract}

\section{Introduction}
\label{sec:Introduction}
It is widely acknowledged among object-oriented programmers that design patterns are useful to solve commonly occurring problems within a given context when coding. Design patterns was mainly introduced to software developers through the GoF (Gang of Four) that came out with the idea in their book from 1995~\cite{bibitem:GoF} the idea originaly came from an architectural concept. The patterns has since been widely discussed and used.

Even though they are so popular there are few empirically justified reasons to use them according to C. Zhang and D. Budgen in their article ``What Do We Know about the Effectiveness of Software Design Patterns?''~\cite{bibitem:Zhang}.

The purpose of this report is to find out if the implementation of a specific design pattern, Strategy [section~\ref{sec:Strategy}], will affect maintainability [section~\ref{sec:Maintainability}] in a positive way.

\subsection{Research Question}
\begin{itemize}
	\item How does the implementation of Strategy design pattern in JavaScript affect Maintainability as measured by Cyclomatic complexity and Lines of code
\end{itemize}
\subsection{Strategy design pattern}
\label{sec:Strategy}
\begin{figure}[ht!]
	\centering
	\includegraphics[scale=0.7]{Strategy_Pattern_in_UML.png}
	\caption{Strategy pattern in a UML-diagram}
	\label{fig:Strategy}
\end{figure}
Strategy is a behavioral pattern that intends to minimize coupling by encapsulating a family of algorithms and make them interchangeable by abstracting away the algorithms different functionalities into separate classes that implements a common interface, which is called strategy. An UML-diagram over the concept is shown in [Figure \ref{fig:Strategy}]

\subsection{SOLID}
The purpose of many design patterns is to solve some of the SOLID-violations that can arise when working on bigger projects. SOLID is an mnemonic acronym that stands for
\begin{itemize}
    \item Single responsibility \\
    Each class should only have responsibility over one part of the softwares functionality.
    \item Open-closed \\
    Classes, functions and so on, should be open for extension but closed for modification.
    \item Liskov substitution \\
    Every subtype should be able to replace its inherited type.
    \item Interface segregation \\
    Clients should not be forced to implement methods from and interface that it will not use.
    \item Dependency inversion \\
    High level modules should not be affected by changes of low level modules.
\end{itemize}
All of these principles are good to follow when developing software and are all contributing to code that is easier to maintain~\cite{bibitem:Bob}.

Strategy pattern mainly improves the code with Single responsibility and Open-closed in aspect, although it follows the other principles as well.

\textit{Single Responsibility} through having the code for the algorithms in separate classes.

\textit{Open-closed} since adding a new algorithm the other code will not have to be changed, just add a new class for that algorithm and extend the interface.

\subsection{Maintainability}
\label{sec:Maintainability}
The total cost of maintenance in software development is widely discussed and different eminent names in software development have claimed that it will take up from 40 even up to 60 percent of the time and cost to maintain a project. In the 1990s it was claimed by two experts, Corbi and Yourdon, that software maintainability where going to be one of the major challenges for the 1990s. During the 90s this was confirmed by Hewlett-Packard that claimed that ``they had between 40 and 50 million lines of code under maintenance and that 60 to 80 percent of research and development personnel are involved in maintenance activities''~\cite{bibitem:MetricsToEvaluate}.

\subsection{Metrics}
There are several metrics that tries to measure the complexity of a function or a program. There are a lot of different advancement levels of these metrics, they can range from easily measured metrics like lines of code or cyclomatic complexity to Robillards interconnectivity metric that ``integrates the structural as well as the textual aspects of a program in such a way that the organization of a program can be seen graphically. The measure of complexity depends on how a statement is related to the rest of the program''~\cite{bibitem:Robillard}.

Since the 1990s there have been several attempts to link maintainability with different metrics. In the article Using Metrics to Evaluate Software System Maintainability they found that when they conducted automated software maintainability analysis on 11 softwaresystems. They all corresponded to the experts intuition and also provided additional useful data~\cite{bibitem:MetricsToEvaluate}.

Wei and Henry came to similar conclusion when studing Object-Oriented Metrics that Predict Maintainability~\cite{bibitem:WeiHenry}.

\section{Method}
This section presents the JavaScript implementation of the Strategy pattern as well as the chosen metric to evaluate the solution.

\subsection{Interpretation of the Strategy pattern for JavaScript}
Since JavaScript is not an object oriented language the concept of interface does not exist. In Harmes et al. book ``Pro JavaScript\texttrademark~Design Patterns''~\cite{bibitem:DiazHarmes} the recommendation is to create a Duck Typed interface emulation. This would be useful if the Strategy pattern where used in a real life program to ensure correct parameters where sent to the functions. But since this reports purpose is to evaluate Strategy pattern and uses a quite small example and JavaScript is additionally untyped, the implementation of an interface is skipped and type correctness is assumed.

The example used in this report is taken from an existing game. The code that is supposed to be replaced with the Strategy pattern is a switch case that sets a \texttt{message} dependent on a string. It is part of a method that renders a message in the \texttt{MainUI} from the method parameter \texttt{entity}, see [Listing \ref{lst:switch-case}].

The switch case is a violation of the Open/closed principle the goal is to replace it with the calls in [Listing \ref{lst:strategy}]. This is similar to how the call would look like in the object oriented language Java, a difference is that since JavaScript is untyped everything instantiated with \texttt{var}. The property \texttt{messageType} is replaced with what a more appropriate name \texttt{messageStrategy} and shall be a reference to the correct function instead of a string, e.g.

\begin{lstlisting}[language=JavaScript]
// New
entity.messageStrategy = new humanStrategy();
// Old
entity.messageType = "HumanMessage";
\end{lstlisting}

The Strategy pattern will be implemented in a separate file called \texttt{Messager.js}. It contains a prototype \texttt{Messager(strategy)} that takes a strategy and saves it to its own context \texttt{this}. It also contains a method \texttt{getMessage(...)} that calls the method \texttt{getMessage(...)} on the strategy bound to the context of \texttt{Messager}. The different strategies are in this case also placed in the file \texttt{Messager.js}, so when a new one is needed is just needs to be added to this file. For the resulting file see [Listing \ref{lst:result}].

\subsection{Metrics}
The chosen metrics for this report are cyclomatic complexity and lines of code, they are quite easy to measure and is applicable to many languages.

\subsubsection{Cyclomatic complexity}
id anad switch....

\subsubsection{Lines of code}
The higher amount of lines of code the worse maintainability, excluding whitespace and comments....

\section{Result}
The result of the two metrics are presented below

\subsection{Cyclomatic complexity}
The cyclomatic complexity of the original code is three, one for each case in the switch case.

After the implementation of the Strategy pattern the complexity is reduced down to one.

\subsection{Lines of code}
The number of lines of code in the original code is 18.

After the implementation of the Strategy pattern the total number of lines of code is increased to 29 (excluding whitespace), though \texttt{MainUI.js} is reduced down to 5 lines.

\section{Discussion}
The result and method is discussed in the following subsections.

\subsection{Method}
Something something

\subsection{Result}
The cyclomatic complexity was completely removed from the function \texttt{showMessage} which was the expected result comparing with code examples found at two websites, though they were in the object oriented languages.

One example is by Gil Fink, that has among other co-authored several Microsoft Official Courses. He writes in a blog post about ``Applying Strategy Pattern Instead of Using Switch Statements'' where he applies the Strategy pattern to C++.~\cite{bibitem:GilFink}

The other example though from an unknown source. It is a similar implementation of the Strategy pattern made in C\#.~\cite{bibitem:CSharp}

\section{Conclusion}
The definition of the Strategy pattern from the GoF is in some ways lost when translated into JavaScript. Interfaces does not exist and since it is untyped there would be no purpose using inheritance for this pattern. Though if the strategy pattern would be used reoccurring in a project the Duck Typed interface implementation by Harmes et al. is recommended to gain robuster code.~\cite{bibitem:DiazHarmes}

The SOLID principles can be beneficial to implement in JavaScript if the project tries to do a object oriented inspired design. Design pattern such as Strategy pattern can be implemented quite similarly as shown in this report and gain some of the benefits to Single responsibility and Open-closed principals.

Despite the benefits, this report shows that the implementation can increase total lines of code which may have a maintainability drawback. And in search for a in depth evaluation of the pattern in JavaScript the results where only examples of different implementations in JavaScript and explanations why the pattern is beneficial in general object oriented design.

\clearpage
\appendix

\begin{lstlisting}[language=JavaScript, label=lst:switch-case, caption=\texttt{MainUI.js} The original switch case.]
// Creates and shows a message dependent on entity.messageType
MainUI.prototype.showMessage = function(entity) {
	var message;
	switch(entity.messageType) {
		case "HumanMessage":
			...
			message = ...
			break;
		case "ZombieMessage":
			...
			message = ...
			break;
		case "MonsterMessage":
			...
			message = ...
			break;
	}
	...
};
\end{lstlisting}

\begin{lstlisting}[language=JavaScript, label=lst:strategy, caption=\texttt{MainUI.js} Switch case replaced trough the Strategy pattern.]
// Creates and shows a message dependent on entity.messageStategy
MainUI.prototype.showMessage = function(entity) {
	var messager = new Messager(entity.messageStrategy);
	var message = messager.getMessage(...);
	...
};
\end{lstlisting}
\newpage
\begin{lstlisting}[language=JavaScript, label=lst:result, caption=\texttt{Messenger.js} Resultant Strategy code\, strategy function names are the values of \texttt{ObjectTypeEnum}.]
Messager = function(strategy) {
  this.strategy = strategy;
};

Messager.prototype.getMessage = function(...) {
  return this.strategy.getMessage(...);
};

var humanStrategy = function() {
  this.getMessage = function(...) {
    ...
    return message;
  };
};

var zombieStrategy = function() {
	this.getMessage = function(...) {
		...
		return message;
	};
};

var monsterStrategy = function() {
	this.getMessage = function(...) {
		...
		return message;
	};
};
\end{lstlisting}
\newpage
\begin{thebibliography}{1}
\bibitem{bibitem:GoF}
Erich Gamma, Richard Helm, Ralph Johnson and John Vlissides, \emph{Design Patterns: Elements of Reusable Object-Oriented Software}, \hskip 1em plus 0.5em minus 0.4em\relax Addison-Wesley Professional, 1st edition, January 15, 1995
\bibitem{bibitem:Zhang}
Cheng Zhang and David Budgen, \emph{What Do We Know about the Effectiveness of Software Design Patterns?}, \hskip 1em plus 0.5em minus 0.4em\relax IEEE Transactions on Software Engineering, vol. 38, no. 5, pp. 1213-1231, September-October 2012
\bibitem{bibitem:Bob}
Robert C.~Martin, \emph{Principles Of OOD}, \hskip 1em plus 0.5em minus 0.4em\relax \url{http://butunclebob.com/ArticleS.UncleBob.PrinciplesOfOod}, Accessed: 2015-10-17, Dates back to at least 2003
\bibitem{bibitem:MetricsToEvaluate}
Don Coleman, Dan Ash, Bruce Lowther and Paul Oman, \emph{Using Metrics to Evaluate Software System Maintainability}, \hskip 1em plus 0.5em minus 0.4em\relax Computer, Volume:27,  Issue: 8, August, 1994
\bibitem{bibitem:Robillard}
Pierre N.~Robillard and Germinal Boloix, \emph{The Interconnectivity Metrics: A New Metric Showing How a Program Is Organized}, \hskip 1em plus 0.5em minus 0.4em\relax Journal of Systems and Software, Volume 10, Issue 1, July 1989, Pages 29-39
\bibitem{bibitem:WeiHenry}
Wei Li and Sallie Henry, \emph{Object-Oriented Metrics that Predict Maintainability}, \hskip 1em plus 0.5em minus 0.4em\relax Journal of Systems and Software, Volume 23, Issue 2, November 1993, Pages 111-122
\bibitem{bibitem:DiazHarmes}
Dustin Diaz and Ross Harmes, \emph{Pro JavaScript design patterns}, \hskip 1em plus 0.5em minus 0.4em\relax Apress, 2008
\bibitem{bibitem:GilFink}
Gil Fink, \emph{Applying Strategy Pattern Instead of Using Switch Statements}, \url{http://blogs.microsoft.co.il/gilf/2009/11/22/applying-strategy-pattern-instead-of-using-switch-statements/}, Accessed: 2017-06-07
\bibitem{bibitem:CSharp}
\emph{How to use Strategy Pattern Instead of Switch-Case statements}, \url{https://vcpptips.wordpress.com/tag/cyclomatic-complexity/}, Accessed: 2017-06-07
\end{thebibliography}

\end{document}
